, statement = "SELECT *
FROM public.mortiprovincia")
#formating date and numeric column
db_data$data <- zoo::as.Date(as.numeric(db_data$data), origin="1970/01/01")
db_data[,c("day","nuovi_casi","casi_att_positivi","decessi","decessi_tot","tasso_letalita","tasso_incidenza_100_mila")] <-
apply(db_data[,c("day","nuovi_casi","casi_att_positivi","decessi","decessi_tot","tasso_letalita","tasso_incidenza_100_mila")],2,function(x) as.numeric(x))
db_data <- as_tibble(db_data)
db_data <- db_data[order(db_data$data,db_data$provincia),]
}
# identifying new records
{
dataProvinces$key <- apply(dataProvinces[,1:7],1,paste0,collapse="")
db_data$key <- apply(db_data[,1:7],1,paste0, collapse="")
dataProvinces$key <- gsub('\\s+', '', dataProvinces$key)
db_data$key <- gsub('\\s+', '', db_data$key)
loc <- which(dataProvinces$key %in% db_data$key)
newdata_upload <- dataProvinces[-loc,]
dataProvinces$key <-NULL; db_data$key <-NULL;newdata_upload$key <- NULL
}
# List of tables present in database
RPostgres::dbListTables(con)
View(newdata_upload)
{
#INSERT data into the temporary table
{
tryCatch({
for (i in 1:nrow(newdata_upload)){
print(i)
query <- paste0("INSERT INTO tmpmortiprovincia VALUES (",
"'",newdata_upload[i, 'Provincia'],"'",", ",
"'",newdata_upload[i, 'Day'],"'",", ",
newdata_upload[i, 'Data'],", ",
newdata_upload[i, 'Nuovi_Casi'],", ",
newdata_upload[i, 'Casi_Att_Positivi'],", ",
newdata_upload[i, 'Decessi'],", ",
newdata_upload[i, 'Decessi_Tot'],", ",
newdata_upload[i, 'Tasso_Letalita'],", ",
newdata_upload[i, 'Tasso_Incidenza_100_Mila'], ");")
RPostgreSQL::dbSendQuery(conn = con
, statement = query)
}
}, error = function(e) {
print(paste0("ERRORE : ", newdata_upload[i,]))
message(e)
})
}
## Retrieve records
RPostgreSQL::dbSendQuery(conn = con
, statement = "INSERT INTO public.mortiprovincia
SELECT DISTINCT *
FROM public.tmpmortiprovincia
WHERE
NOT EXISTS (
SELECT *
FROM public.mortiprovincia
WHERE mortiprovincia.provincia = tmpmortiprovincia.provincia
AND mortiprovincia.day = tmpmortiprovincia.day
AND mortiprovincia.data = tmpmortiprovincia.data
);")
RPostgreSQL::dbSendQuery(conn = con
, statement = "DELETE
FROM public.tmpmortiprovincia
;")
}
#Github dataset
{
con <- RPostgreSQL::dbConnect(RPostgres::Postgres()
, dbname = "COVID19"
, host="unisid-dm-demm.unisid.unimi.it"
, port="5432"
, user="getTweet"
, password="1029qpwo")
database <- RPostgreSQL::dbGetQuery(conn = con
, statement = "SELECT provincia, data, decessi, decessi_tot, nuovi_casi, casi_att_positivi
FROM public.mortiprovincia
ORDER BY Data")
#formating date and numeric column
database$data <- zoo::as.Date(as.numeric(database$data), origin="1970/01/01")
database[,c("nuovi_casi","casi_att_positivi","decessi","decessi_tot")] <-
apply(database[,c("nuovi_casi","casi_att_positivi","decessi","decessi_tot")],2,function(x) as.numeric(x))
database <- as_tibble(database)
database <- database[order(database$data,database$provincia),]
}
istatPath <- "/home/alice/Downloads/dpc-covid19-ita-province.csv"
istatCode <- read_csv2(istatPath)
istatCode <- dplyr::distinct(istatCode[,c("denominazione_provincia"
, "codice_provincia"
, "denominazione_regione"
, "codice_regione")]) %>%
filter(denominazione_provincia != "In fase di definizione/aggiornamento")
istatCode$denominazione_provincia[istatCode$denominazione_provincia=="Forl√¨-Cesena"] <- "Forli-Cesena"
istatCode$denominazione_provincia[istatCode$denominazione_provincia=="L'Aquila"] <- "L Aquila"
istatCode$denominazione_provincia[istatCode$denominazione_provincia=="Reggio nell'Emilia"] <- "Reggio nell Emilia"
gitDB <- dplyr::left_join(database, istatCode
, by=c("provincia" = "denominazione_provincia"))
colnames(gitDB)
gitDataSet <- gitDB[,c("codice_provincia", "provincia", "data", "decessi", "decessi_tot", "nuovi_casi", "casi_att_positivi", "denominazione_regione", "codice_regione")]
colnames(gitDataSet) <- c("id_prov", "Province", "Date", "Deaths", "Tot_deaths", "New_cases", "Curr_pos_cases", "Region", "id_reg")
gitDataSet
# Write to csv
write_csv(gitDataSet, "/home/alice/Desktop/COVID-Pro-Dataset/deathsItaProv.csv")
matrix(data = c(1,2,3,4,5,6), # the data elements
ncol = 3,              # number of columns
nrow = 2,              # number of rows
byrow = TRUE))
M <- matrix(data = c(1,2,3,4,5,6), ncol = 3, nrow = 2, byrow = TRUE)
M
M <- matrix(data = c(1,2,3,4,5,6), ncol = 3, nrow = 2, bycol = TRUE)
M
M <- matrix(data = c(1,2,3,4,5,6), ncol = 3, nrow = 2, bycol = TRUE)
M
M <- matrix(data = c(1,2,3,4,5,6), ncol = 3, nrow = 2, byrow = FALSE)
M
M <- matrix(data = c(1,2,3,4,5,6), ncol = 2, nrow = 3, byrow = FALSE)
M
# Generating a named matrix
M <- matrix(data = c(1,2,3,4,5,6), # the data elements
ncol = 2,              # number of columns
nrow = 3,              # number of rows
byrow = TRUE)          # fill matrix by rows
rn <- c('1','2', '3')       # vector of rownames
cn <- c('A','B')  # vector of colnames
rownames(M) <- rn        # assign rownames
colnames(M) <- cn        # assign colnames
M
# Generating a named matrix
M <- matrix(data = c(1,2,3,4,5,6), # the data elements
ncol = 2,              # number of columns
nrow = 3,              # number of rows
byrow = FALSE)          # fill matrix by rows
rn <- c('1','2', '3')       # vector of rownames
cn <- c('A','B')  # vector of colnames
rownames(M) <- rn        # assign rownames
colnames(M) <- cn        # assign colnames
M
i <- M[,'A'] + M[,'B']
M[i, 'S']
x <- list()
x$val <- 1
myFun <- function(x){x$val <- x$val+1}
myFun(x)
x$val
x <- list()
x$val <- 1
myFun <- function(x){x$val <- x$val+1}
myFun(x)
x$val
x <- new-env()
x$val <- 1
myFun <- function(x){x$val <- x$val+1}
myFun(x)
x$val
x <- new.env()
x$val <- 1
myFun <- function(x){x$val <- x$val+1}
myFun(x)
x$val
class(c(NULL, 10, NA, "unknown"))
is.xts(1)
View(x)
x<- 1
for (i in 1:10){
if(i==8) x<-1
if(i==9)next
x<- x+1
}
x
x<- 1
for (i in 1:10){
if(i==8) x<-1
if(i==9)next
x<- x+1
}
x
x <- c(1,4)
y <- c(4,1)
z <- x+y
z
x<- 2
for(i in 1:3){
x <- x*2
}
x
x<- 2
for(i in 1:3){
x <- x*2
}
x
x <- list()
x$val <- 1
myfun <- function(x){x$val <- x$val + NA}
myfun(x)
x$val
x <- new.env()
x$val <- 18
myfun <- function(x){x$val <- x$val + NA}
myfun(x)
x$val
x <- c("a"=1, "b"=2, "c"=3, "d"=4, "e"=5)
x
x<-c(FALSE, FALSE, FALSE, TRUE, FALSE)
x
Text of the books downloaded from:
# A Mid Summer Night's Dream:
#  http://www.gutenberg.org/cache/epub/2242/pg2242.txt
# The Merchant of Venice:
#  http://www.gutenberg.org/cache/epub/2243/pg2243.txt
# Romeo and Juliet:
#  http://www.gutenberg.org/cache/epub/1112/pg1112.txt
function(input, output, session) {
# Define a reactive expression for the document term matrix
terms <- reactive({
# Change when the "update" button is pressed...
input$update
# ...but not for anything else
isolate({
withProgress({
setProgress(message = "Processing corpus...")
getTermMatrix(input$selection)
})
})
})
# Make the wordcloud drawing predictable during a session
wordcloud_rep <- repeatable(wordcloud)
output$plot <- renderPlot({
v <- terms()
wordcloud_rep(names(v), v, scale=c(4,0.5),
min.freq = input$freq, max.words=input$max,
colors=brewer.pal(8, "Dark2"))
})
}
Text of the books downloaded from:
# A Mid Summer Night's Dream:
#  http://www.gutenberg.org/cache/epub/2242/pg2242.txt
# The Merchant of Venice:
#  http://www.gutenberg.org/cache/epub/2243/pg2243.txt
# Romeo and Juliet:
#  http://www.gutenberg.org/cache/epub/1112/pg1112.txt
function(input, output, session) {
# Define a reactive expression for the document term matrix
terms <- reactive({
# Change when the "update" button is pressed...
input$update
# ...but not for anything else
isolate({
withProgress({
setProgress(message = "Processing corpus...")
getTermMatrix(input$selection)
})
})
})
# Make the wordcloud drawing predictable during a session
wordcloud_rep <- repeatable(wordcloud)
output$plot <- renderPlot({
v <- terms()
wordcloud_rep(names(v), v, scale=c(4,0.5),
min.freq = input$freq, max.words=input$max,
colors=brewer.pal(8, "Dark2"))
})
}
Text of the books downloaded from:
# A Mid Summer Night's Dream:
#  http://www.gutenberg.org/cache/epub/2242/pg2242.txt
# The Merchant of Venice:
#  http://www.gutenberg.org/cache/epub/2243/pg2243.txt
# Romeo and Juliet:
#  http://www.gutenberg.org/cache/epub/1112/pg1112.txt
function(input, output, session) {
# Define a reactive expression for the document term matrix
terms <- reactive({
# Change when the "update" button is pressed...
input$update
# ...but not for anything else
isolate({
withProgress({
setProgress(message = "Processing corpus...")
getTermMatrix(input$selection)
})
})
})
# Make the wordcloud drawing predictable during a session
wordcloud_rep <- repeatable(wordcloud)
output$plot <- renderPlot({
v <- terms()
wordcloud_rep(names(v), v, scale=c(4,0.5),
min.freq = input$freq, max.words=input$max,
colors=brewer.pal(8, "Dark2"))
})
}
function(input, output, session) {
# Define a reactive expression for the document term matrix
terms <- reactive({
# Change when the "update" button is pressed...
input$update
# ...but not for anything else
isolate({
withProgress({
setProgress(message = "Processing corpus...")
getTermMatrix(input$selection)
})
})
})
# Make the wordcloud drawing predictable during a session
wordcloud_rep <- repeatable(wordcloud)
output$plot <- renderPlot({
v <- terms()
wordcloud_rep(names(v), v, scale=c(4,0.5),
min.freq = input$freq, max.words=input$max,
colors=brewer.pal(8, "Dark2"))
})
}
function(input, output, session) {
# Define a reactive expression for the document term matrix
terms <- reactive({
# Change when the "update" button is pressed...
input$update
# ...but not for anything else
isolate({
withProgress({
setProgress(message = "Processing corpus...")
getTermMatrix(input$selection)
})
})
})
# Make the wordcloud drawing predictable during a session
wordcloud_rep <- repeatable(wordcloud)
output$plot <- renderPlot({
v <- terms()
wordcloud_rep(names(v), v, scale=c(4,0.5),
min.freq = input$freq, max.words=input$max,
colors=brewer.pal(8, "Dark2"))
})
}
runGitHub(repo, username = getOption("aliceiordache"), ref = "master",
subdir = NULL, ...)
install.packages("shiny")
library(shiny)
runExample("01_hello")
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Fulmicotone!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "mamma",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Fulmicotone!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "mamma",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Fulmicotone!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "mamma",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Fulmicotone!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "mamma",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Load and install packages if required
if (!require("pacman"))
install.packages("pacman")
pacman::p_load(
shiny,
shinydashboard,
dplyr,
wordcloud,
quanteda,
memoise,
tm,
RColorBrewer,
shinycssloaders,
plotly
)
# Load data
got <<- read.csv("got_scripts_breakdown.csv",
stringsAsFactors = F,
sep = ";")
# Load data
got <<- read.csv("got_scripts_breakdown.csv",
stringsAsFactors = F,
sep = ";")
# Load data
got <<- read.csv("got_scripts_breakdown.csv",
stringsAsFactors = F,
sep = ";")
library(shiny)
runGitHub("aliceiordache", "R-Shiny-app-midterm", ref = "main")
# REMOVED. IN ORDER TO RUN THE APP,
# ONE WILL SIMPLY RUN THE FOLLOWING COMMANDS FROM
# THE CONSOLE (WITHOUT WRITING THEM IN THIS SCRIPT):
#
# library(shiny)
# runGitHub("github_username", "github_reponame", ref = "main")
#
# EDIT THE 'REF' PARAMETER VALUE WITH THE GITHUB
# BRANCH NAME.
#########################
shinyApp(ui, server)
library(shiny)
runGitHub("aliceiordache", "R-Shiny-app-midterm", ref = "main")
library(shiny)
runGitHub("aliceiordache", "R-Shiny-app-midterm", ref = "main")
library(shiny)runGitHub("R-Shiny-app-midterm", "aliceiordache", ref = "main")
library(shiny)runGitHub("R-Shiny-app-midterm", "aliceiordache", ref = "main")
library(shiny)
runGitHub("R-Shiny-app-midterm", "aliceiordache", ref = "main")
shiny::runApp('Desktop/R-Shiny-app-midterm')
